## useContext

`const value = useContext(SomeContext)` 从组件顶层调用，来读取和订阅上下文  
`useContext`返回调用组件的上下文值  
`SomeContext`本身不保存信息，仅提供或从组件中读取的信息类型  
`<SomeContext.Provider>`位于 useContext 组件之上，若没有 provider 那么返回上下文的 dafault value  
`createContext`返回最新值，且上下文发生变化 react 会自动重新渲染并读取上下文组件

- tips：React 会自动重新渲染所有特定的上下文的子级，在接受提供者的 value 开始比较，若相同会跳过重新渲染并 memo，反之接收新的上下文值

## useId

生成可以传递给可访问属性的唯一的 id，从调用组件的'parent path‘生成  
`const id = userId（ ）` useId 不带任何参数，且返回唯一的 id 字符串  
不要将生成的 id 用于生成列表的 key 值

## useRef

引用渲染不需要的值`const ref = useRef（initialValue）`，返回单个属性的对象
在顶层调用以声明一个或多个引用
参数：`initialValue`是 ref 对象的 current 属性的初始值，可以是任何类型的值（null 也可以），初次渲染之后被忽略

##### tips：

- 除初始化外，不要在渲染期间读写，且更改 ref 不会触发重新渲染，若必须则用 state 读写，所以 ref 适合存储不影响组件视图输出的信息
- ref 的 current 的属性是可变的，但更改后不会重新渲染组件；
- ref 可以在重新渲染之间存储信息；
- 更改 ref 不会触发重新渲染
- ref 对于每个组件来说都是本地的

# es6

### let 和 const 命令

- 暂时性死区和 let、const 语句不出现变量提升
  let：只在所在代码块生效（单独作用域），不允许在相同作用域内，重复声明同一个变量。
  var：全局范围都生效（全局作用域）
  const： 1.只在声明所在的块级作用域内有效，不允许在相同作用域内，重复声明同一个变量。 2.变量指向的那个内存地址所保存的数据不得改动

#### 暂时性死区

本质：只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。

#### 块级作用域

允许块级作用域的任意嵌套，且内层作用域可以定义外层作用域的同名变量

### 变量的解构赋值

- 数组的解构赋值：

1.  “模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值 eg：`let [x, z , y] = [1, 2, 3];//x=1，z=2，y=3`
2.  如果解构不成功，变量的值就等于 undefined。
3.  解构赋值允许指定默认值，但是只有当一个数组成员严格等于 undefined，默认值才会生效（数组成员是 null，默认值就不会生效，null 不全等 undefined）。
4.  数组的元素是按次序排列的，变量的取值由它的位置决定；

- 对象的解构赋值：

1. 对象的属性没有次序，变量必须与属性同名，才能取到正确的值。eg： `let { b, f } = { f: 'aa', b: 'bb' };// f "aa" ；b "bb"`
2. 解构失败，变量的值等于 undefined。eg： `let { h } = { f: 'aa', b: 'bb' }; //h undefined`
3. 可以将现有对象的方法，赋值到某个变量。eg： `let { log, sin, cos } = Math;`
4. 对象的解构赋值可以取到继承的属性
5. 对象的解构可以指定默认值，需要对象的属性值严格等于 undefined。

- 字符串解构赋值

- 数值和布尔值的解构赋值

1. 如果等号右边是数值和布尔值，则会先转为对象。
2. 只要等号右边的值不是对象或数组，就先将其转为对象。由于 undefined 和 null 无法转为对象，所以对它们进行解构赋值，都会报错。

- 函数参数的解构赋值
  函数参数的解构可以使用默认值
  eg： `[[1, 2], [3, 4]].map(([a, b]) => a + b);// [ 3, 7 ]`

* 不能使用圆括号的情况

1. 变量声明语句
2. 函数参数
3. 赋值语句的模式

# fetch（）

全局的 fetch()方法是用于发起获取资源的请求。
会返回一个 promise，promise 会在请求响应后被 resolve，并传回 Response 对象。
但是遇到网络错误（其中 HTTP 404 状态并不被认为是网络错误）时，fetch() 返回的 promise 是会被 reject，同时会传回 TypeError，这也可能因为权限或其他问题导致。
所以，fetch() 检查要包括 ：

1. promise 被 resolve
2. Response.ok 属性为 true
