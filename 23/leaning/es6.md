# es6

### let 和 const 命令

- 暂时性死区和 let、const 语句不出现变量提升
  let：只在所在代码块生效（单独作用域），不允许在相同作用域内，重复声明同一个变量。
  var：全局范围都生效（全局作用域）
  const： 1.只在声明所在的块级作用域内有效，不允许在相同作用域内，重复声明同一个变量。 2.变量指向的那个内存地址所保存的数据不得改动

#### 暂时性死区

本质：只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。

#### 块级作用域

允许块级作用域的任意嵌套，且内层作用域可以定义外层作用域的同名变量

### 变量的解构赋值

- 数组的解构赋值：

1.  “模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值 eg：`let [x, z , y] = [1, 2, 3];//x=1，z=2，y=3`
2.  如果解构不成功，变量的值就等于 undefined。
3.  解构赋值允许指定默认值，但是只有当一个数组成员严格等于 undefined，默认值才会生效（数组成员是 null，默认值就不会生效，null 不全等 undefined）。
4.  数组的元素是按次序排列的，变量的取值由它的位置决定；

- 对象的解构赋值：

1. 对象的属性没有次序，变量必须与属性同名，才能取到正确的值。eg： `let { body, footer } = { footer: 'aa', body: 'bb' };// footer "aa" ；body "bb"`
2. 解构失败，变量的值等于 undefined。eg： `let { header } = { footer: 'aa', body: 'bb' }; //header undefined`
3. 可以将现有对象的方法，赋值到某个变量。eg： `let { log, sin, cos } = Math;`
4. 对象的解构赋值可以取到继承的属性
5. 对象的解构可以指定默认值，需要对象的属性值严格等于 undefined。

- 字符串解构赋值

- 数值和布尔值的解构赋值

1. 如果等号右边是数值和布尔值，则会先转为对象。
2. 只要等号右边的值不是对象或数组，就先将其转为对象。由于 undefined 和 null 无法转为对象，所以对它们进行解构赋值，都会报错。

- 函数参数的解构赋值
  函数参数的解构可以使用默认值
  eg： `[[1, 2], [3, 4]].map(([a, b]) => a + b);// [ 3, 7 ]`

* 不能使用圆括号的情况

1. 变量声明语句
2. 函数参数
3. 赋值语句的模式
