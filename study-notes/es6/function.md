# 函数的扩展

## 函数参数的默认值

ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面

-   如果参数在调用时没有提供值，将使用默认值           
    默认值可以是表达式          
    如果参数传递了 undefined，默认没有提供值，则默认值生效          
    默认值表达式在函数调用时才会求值，而不是在函数定义时         
    在函数内部，不再有 arguments 对象，但命名参数仍然可以通过变量访问         
    在同一函数中，不能再使用 var、let 或 const 重新声明已经作为参数声明的变量            

```es6
const functionName = (name = "Guest") => {
    console.log(`Hello, ${name}!`);
};

functionName(); // Output: Hello, Guest!
functionName(undefined); // Output: Hello, Guest!
functionName("User"); // Output: Hello, User!
```

### length 属性

-   指定了默认值的参数：
    
    length 属性等于函数的参数个数减去指定了默认值的参数个数         
    length 属性表示函数期望传入的参数个数，而默认值的参数在调用函数时可以省略             

-   rest 参数不计入 length 属性：

-   默认值不是尾参数：

如果设置了默认值的参数不是函数参数列表的尾部参数，那么后面的参数也不会计入函数的 length 属性

### 作用域

-   参数默认值形成作用域：

    当函数参数有默认值时，会在函数内部形成一个独立的作用域       
    在该作用域中，参数默认值可以引用其他函数参数或外部作用域中的变量          

-   默认值是参数的情况：

    在函数内部，如果参数的默认值是函数的其他参数，该参数默认值会在独立的作用域中寻找对应的值

-   默认值作用域屏蔽：
    
    当参数的默认值作用域内存在同名变量时，函数参数默认值不受局部作用域内的变量影响，仍然引用外部作用域中的变量

-   默认值为函数的情况：
    
    当参数的默认值是一个函数时，该函数内部形成独立作用域，但是在作用域内找不到变量时，会回溯到外部作用域查找

-   函数内多个作用域：

    函数内部可以形成多个作用域，在函数中声明了多个变量，每个作用域内的变量相互独立，不会相互影响

## rest 参数

-   基本语法：使用 rest 参数（形式为 ...变量名）来获取函数的多余参数，这些参数将会被放入一个数组中

-   替代 arguments 对象

-   数组特性：可以使用数组的方法和属性，无需进行转换

-   位置限制：只能出现在函数参数列表的末尾，不能在其他参数之前

-   函数的 length 属性不包括 rest 参数

## 严格模式

-   函数内部的严格模式：通过在函数体的开头添加 'use strict' 来启用

-   ES2016 对严格模式的规定：函数参数使用了默认值、解构赋值或扩展运算符时，函数内部不能显式设定严格模式，否则报错

-   限制的原因：

    为了解决参数和函数体的执行顺序问题：函数参数会先执行，然后才执行函数体。因此，在参数代码执行时，无法预知函数体是否应该以严格模式执行

-   规避限制的方法：
    
    在整个脚本文件或模块中使用全局性的严格模式       
    将函数包裹在一个无参数的立即执行函数中，然后在该函数内部使用严格模式       

## name 属性

1. `name` 属性基本用法： 函数的 `name` 属性返回函数的名称

2. 匿名函数的 `name` 属性：

    ES5 中，匿名函数赋值给变量时，`name` 属性返回空字符串。而在 ES6 中，`name` 属性会返回实际的函数名

    ```es6
    var f = function () {};

    // ES5
    f.name; // ""

    // ES6
    f.name; // "f"
    ```

3. 具名函数的 `name` 属性：

    对于具名函数赋值给变量，ES5 和 ES6 的 `name` 属性都返回函数的原始名称

    ```es6
    const bar = function baz() {};

    bar.name; // "baz"
    ```

4. `Function` 构造函数和 `bind` 返回的函数：

    - 使用 `Function` 构造函数返回的函数实例，`name` 属性的值为 `"anonymous"`

    ```es6
    new Function().name; // "anonymous"
    ```

    - 使用 `bind` 返回的函数，`name` 属性值会添加 `"bound"` 前缀

    ```es6
    function foo() {}
    foo
        .bind({})
        .name(
            // "bound foo"
            function () {}
        )
        .bind({}).name; // "bound "
    ```

## 箭头函数

### 基本用法

1. 定义箭头函数：通过单个参数、多个参数，甚至没有参数来定义函数

2. 单行隐式返回： 如果箭头函数的函数体只有一条语句，可以省略大括号，并且该语句的结果会被隐式返回

3. 多行函数体：

    如果箭头函数的函数体有多条语句，需要使用大括号，并且需要使用 `return` 显式返回结果

4. 对象返回需要括号

5. 如果箭头函数只有一行语句，且不需要返回值，可以使用 `void` 关键字来显式指示不返回任何值

6. 与变量解构结合使用

    ```es6
    const full = ({ first, last }) => first + " " + last;
    ```

7. 简化回调函数：

    ```es6
    [1, 2, 3].map((x) => x * 2);
    ```

8. 与 rest 参数结合使用：

    ```es6
    const headAndTail = (head, ...tail) => [head, tail];
    ```

### 使用注意点

-   没有自己的 this： 箭头函数继承外层作用域的 this，固定化了内部的 this 值

    1. 内部 this 指向外层 this：

        箭头函数内部的 this 指向最近的非箭头函数作用域的 this 值，不是调用者或运行时对象

    2. 固定化封装回调函数：

        可以固定化回调函数内部的 this 值，避免 this 指向问题

    3. 嵌套箭头函数也继承外层 this：嵌套箭头函数继承相同的外层 this 值

    4. 不可改变 this 指向：

        不能用 call()、apply()、bind() 等方法来改变内部 this 指向

-   不支持 arguments、super、new.target：

    箭头函数内部也没有自己的 arguments、super、new.target 变量，继承自外层

-   没有 arguments 对象：箭头函数内部没有自己的 arguments 对象，可用 rest 参数替代

-   不能使用 yield：不能用作 Generator 函数，不支持 yield 命令

-   不能作为构造函数：不可以使用 new 关键字来创建实例

### 不适用

1. 定义对象方法：当需要在对象的方法内部使用 `this` 关键字来引用当前对象时，不应该使用箭头函数。箭头函数固定了 `this` 指向，会导致 `this` 指向全局对象或外层作用域，而不是对象本身

2. 需要动态 this：当需要在函数内部动态地使用 `this` 指向，箭头函数将 `this` 固定在函数定义时的作用域，而不是动态地绑定到函数调用者

### 嵌套的箭头函数

箭头函数内部，可以再使用箭头函数               
箭头函数在嵌套时继承外层函数的 this 值，不单独拥有自己的 this 对象            
嵌套箭头函数无法使用 call()、apply()、bind() 等方法改变内部的 this 指向             

## 尾调用

函数执行的最后一步是调用另一个函数

-   特点：
    当前函数执行的最后一步，之后不会再有其他操作。JavaScript 引擎可以优化内存空间，将当前函数的调用帧替换为被调用函数的调用帧，从而减少函数调用栈的深度

### 优化

特指在函数调用的最后一步操作为函数调用时的优化方式

-   核心思想
    如果一个函数调用是另一个函数调用的最后一步操作，那么就可以优化掉当前函数的调用帧，只保留被调用函数的调用帧，从而减少内存的使用

### 尾递归

函数调用自身，称为递归。如果尾调用自身，就称为尾递归

-   递归非常耗费内存，需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误。但对于尾递归来说，由于只存在一个调用帧，所以不会发生“栈溢出”错误

#### 尾递归和尾调用优化

```es6
// 非尾调用
const factorial = (n) => (n === 1 ? 1 : n * factorial(n - 1));

// 尾调用优化
const optimizedFactorial = (n, initialValue = 1) =>
    n === 1 ? initialValue : optimizedFactorial(n - 1, n * initialValue);
```

### 严格模式

尾调用优化在 ES6 中只在严格模式下生效，正常模式下无效

-   正常模式下，函数内部的两个变量 `func.arguments` 和 `func.caller` 用于跟踪函数的调用栈，而尾调用优化会改写调用栈，导致这两个变量失真。为了避免这种情况，尾调用优化仅在严格模式下生效，严格模式禁用了这两个变量，尾调用优化能够正常进行

## Function.prototype.toString()

toString()方法返回函数代码本身，以前会省略注释和空格，修改后的 toString()方法，明确要求返回一模一样的原始代码

```es6
const functionName = (name) => {
    console.log(`Hello, ${name}!`);
};

const getSourceCode = functionName.toString();
//打印结果
// (name) => {
//     console.log(`Hello, ${name}!`);
// };
```

## 允许 catch 语句省略参数

```es6
try {
    // ...
} catch {
    // ...
}
```
